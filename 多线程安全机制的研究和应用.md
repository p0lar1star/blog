# 多线程安全机制的研究和应用

摘 要   多线程因具有响应速度快、提高CPU利用率、资源共享、切换消耗小等优点被广泛应用于程序设计中。然而它存在的安全性问题同样引起了广泛关注。同一进程中的多线程共享其数据空间会引发临界资源竞争等一系列问题。本文从这个角度探讨多线程应用的安全性问题，同时也将分析实际应用中避免线程间条件竞争的方法。

关键词   进程；多线程；竞争条件

中图法分类号  TP309.2

Research and Application on Security Mechanism of Multithreading

Long Xudong

(School of Computer Science and Engineering, Central South University, Changsha 410083)

**Abstract**  Multithreading is widely used in program design because of its fast response speed, improved CPU utilization, resource sharing and low switching consumption. However, its security problems have also attracted extensive attention. Multithreads sharing their data space in the same process will lead to a series of problems such as critical resource competition. This paper discusses the security of multithreaded applications from this perspective, and also analyzes the methods to avoid conditional competition between threads in practical applications.

**Key words** process, multi-thread, race condition

# **1**   引 言

## **1.1** 进程、线程与多线程

在传统的操作系统中，进程是系统进行资源分配的基本单位，按进程为单位分给存放其映象所需要的虚地址空间、执行所需要的主存空间、完成任务需要的其他各类外围设备资源和文件。同时，进程也是处理器调度的基本单位，进程在任一时刻只有一个执行控制流，通常将这种结构的进程称单线程（结构）进程（single threaded process）。

我们来考察一个文件服务器的例子，当它接受一个文件服务请求后，由于等待磁盘传输而经常被阻塞，假如不阻塞可继续接受新的文件服务请求并进行处理，则文件服务器的性能和效率便可以提高，由于处理这些请求时要共享一个磁盘缓冲区，程序和数据，要在同一个地址空间中操作。这一类应用非常多，例如，航空售票系统需要处理多个购票和查询请求，这些信息都与同一个数据库相关；而操作系统在同时处理许多用户进程的查询请求时，都要去访问数据库所在的同一个磁盘。对于上述这类基于同数据区的同时多请求应用，用单线程结构的进程难以达到这一目标，即使能解决问题代价也非常高，需要寻求新概念、提出新机制。随着并行技术、网络技术和软件设计技术的发展，给并发程序设计效率带来了一系列新的问题，主要表现在：

1.进程时空的开销大，频繁的进程调度将耗费大量处理器时间，要为每个进程分配存储空间限制了操作系统中进程的总数。

2.进程通信的代价大，每次通信均要涉及通信进程之间或通信进程与操作系统之间的信息传递。

3.进程之间的并发性粒度较粗，并发度不高，过多的进程切换和通信延迟使得细粒度的并发得不偿失。

4.不适合并行计算和分布并行计算的要求，对于多处理器和分布式的计算环境来说，进程之间大量频繁的通信和切换，会大大降低并行度。

5.不适合客户/服务器计算的要求。对于 C/S 结构来说，那些需要频繁输入输出并同时大量计算的服务器进程（如数据库服务器、事务监督程序）很难体现效率。

综上，这就迫切要求操作系统改进进程结构，提供新的机制，使得应用能够按照需求在同一进程中设计出多条控制流，多控制流之间可以并行执行，多控制流切换不需通过进程调度；多控制流之间还可以通过内存区直接通信，降低通信开销。这就是近年来流行的多线程（结构）进程（multiple threaded process）。

## **1.2** 多线程的特点

一个进程至少需要一个线程作为它的指令执行体，进程管理着资源比如CPU、内存、文件等等。进程之间空间、时间独立互不干扰。同一进程的多线程间共享其地址空间，可并发执行，且彼此间可能存在着种种联系，或许是共享一段缓存或协调执行一组任务。线程和进程的不同之处如图1所示。

![img](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041801693.gif)

图1 进程和线程的比较

使用多线程最为突出的特点是：与本进程中的其它线程共享大部分资源。对进程来说，它们具有独立的数据空间，需要用复杂的方式实现进程间通 讯和同步。这种方式既费时又不方便。线程则不同，因为同一进程下某一线程的数据空间被同一进程的其它所有线程可见。而且进程间切换需要保存的上下文内容是相当大的，线程间切换消耗的时间和资源是较少的。

## **1.3** 竞争条件

竞争条件是多个进程都企图修改共享的数据，或者进行某种处理，而最终得到的结果又与这些共享相同数据进程的执行顺序有关，也即与这些进程对这一共享资源的竞争有关。这就是竞争条件。下面将举出两个例子。

例如，在计算机内存或存储器里，如果两个线程同时进行读写数据的操作，那么此时竞争条件将有可能发生。程序企图重叠相同的或者之前的数据，但之前旧的数据依旧在被读写。最终可能出现许多种情况：操作可能显示，读取旧的数据出现错误或者写入新的数据出现错误。

又如，在卖票系统中，当某一种票只剩最后一张时，此时有多个用户（也即多个线程）进行买票。假设能否卖到票的条件是系统中的票数大于0，而当一个用户买完最后一张票后，系统还没来得及对票数进行减1操作，此时另外一个用户也进行买票，而且系统中的票数显示是大于0的，所以也成功进行了买票。最终系统中票数为-1，而这将会产生问题，只有一个票却被两个用户买了。

# **2**   多线程中的安全问题与线程安全性

多线程在生产实践中带来极大方便性的同时，也带来了一定的安全隐患：一方面是因为不同线程共享大部分指令和全局变量。例如，每个线程都可能更改线程中记录错误返回值的变量errno，这里假定这个变量被定义为全局变量。因此，当某个线程发生异常而终止时，将更改这个变量的值。又因为异常终止可能发生在线程执行的任何时间，故其它线程随时可能因为errno的值被改变也发生异常终止。这样就造成了线程执行的混乱，甚至是死锁。

另一方面，并发多线程对共享资源的使用将会引起竞争。只要有多个线程在运行，竞争状态就有可能发生，因为任何时候多个线程都可能会同时访问相同的数据。在线程之间访问共享数据很容易使多线程进入“竞争状态”，即其中一个线程在另一个线程完成更新数据之前抢先读取部分更新的数据。例如，在多线程并发控制中，如果一个线程正在将数据写入文件，而另一个线程正在从该文件中读取数据，将无法知道哪个线程先完成，这两个线程都在竞相到达文件末尾，如果读取线程快于写入线程，则将返回无法预料的结果。在多线程设计中竞争状态潜在的安全隐患正在成为一个日趋严重的问题。

线程安全性是指多线程防止出现数据访问竞争的能力。出现数据访问竞争时，数据的正确性将依赖于运行时多个线程访问和修改数据的次序。数据竞争是由于访问共享资源时缺乏或不适当地运用同步机制引起的。如果没有正确地限定某一时刻某一个线程可以访问变量，就会出现数据竞争。此时赢得竞争的线程获得访问许可，但会导致不可预知的结果。若线程的运行时机被实时抢占，运行的线程可以在任何时间中断，所以不能假定先开始运行的线程总是比后开始运行的线程先访问到两者共享的数据。

# **3**   避免多线程竞争条件的策略

在理解了竞争条件的产生是由于对共享资源的竞争操作的原理后。可以根据竞争条件产生的原理采用对应策略进行避免。要阻止竞争条件发生，关键就是不能让多个线程同时访问指定的共享资源。即将要访问的那个资源被定义为临界资源。各种避免竞争条件的策略都是围绕着临界资源而设计的。

要想成功的避免竞争条件，使程序运行结果最终不因多个线程的竞争执行顺序而产生导致结果错误的问题，所提出的方案理论上应该满足以下四个条件。

①任何两个线程不能同时处于临界区

②不能对CPU速度和数量作出任何假设

③不得使线程无限期等待进入临界区

④临界区外运行的线程不得阻塞其他线程

除了最后一个条件外，前三个条件都是可行方案所必须满足的。最后一个方案若不满足，则意味着产生了不必要的等待时间，程序执行效率被降低。

根据以上四个规则，可以得出避免竞争条件的主要方法是互斥。下面介绍一些策略。

## **3.1** 屏蔽中断

在程序准备进入临界区前，屏蔽所有中断，在结束临界区操作后，打开中断。这样，在执行临界区代码时，线程不会因为任何中断条件发生切换，保证了在每一时刻最多只能有一个线程在执行临界区代码。

尽管从理论上可行，在屏蔽中断方法几乎不会被实际采用。首先，将屏蔽终端的权限交给用户具有很大的风险。例如，如果一个线程在将所有终端屏蔽后并未再次打开，则其余所有线程将用于得不到执行的机会，这可能造成系统的崩溃。另一方面，屏蔽终端方法仅使用于单处理器硬件环境。当前线程执行屏幕终端指令时，其仅能将正在运行该线程的CPU的所有中断屏蔽掉，而其他CPU仍可正常中断，因此其他线程仍然有可能进入临界区。目前，多处理器的硬件环境多已成基本配置，因此屏蔽中断方法基本不具有可行性。

将屏蔽中断的权限限制在内核态是一项非常有用的技术。例如内核在更新变量或列表的几条指令期间可以将中断屏蔽，保证操作的原子性。

## **3.2** 采用锁变量

可以考虑使用锁变量来实现多个线程的互斥访问。锁变量为0表示当前没有线程位于临界区当中。对于想要进入临界区的线程，其首先检查当前锁变量的值，如果为0，则更新当前锁变量值为非0值并进入临界区，在退出临界区前，将锁变量重新置为0。其伪代码如下：

```c
//非临界区代码

……

//进入临界区

WHILE(*lock* != 0){

    *lock* = 1;

//临界区代码

    ……

    *lock* = 0;

}

//非临界区代码

……
```

该方法看似可行，然而仔细分析就会发现，该代码仍然无法实现线程在临界区的互斥。假设线程0准备进入临界区，其检查锁变量，发现其值为0，此时发生时钟中断，切换到线程1，线程1检查锁变量，发现其值为0，然后进入临界区，修改锁变量的值为1，进而开始执行临界区代码。若在执行临界区的过程中，CPU发生时钟中断，再次切换会线程0。此时线程0顺序执行下一条指令，其进入临界区，修改lock变量为1。这时，麻烦来了，线程0和线程1同时进入了临界区。

出现以上问题的原因在于线程对与锁变量的访问与修改不是原子操作，在对锁变量的访问与修改的间隙可能发生时钟中断，因此无法保证仅有一个线程位于临界区。

## **3.3** 严格轮换法

如果我们可以严格制定多个线程在临界区的运行次序，则可以避免多个线程同时进入临界区。

严格轮换法使用变量turn记录当前拥有在临界区运行权限的线程编号，在当前线程执行完临界区代码，准备退出前，其将turn变量设置为下一具有临界区运行权限的线程编号，实现权限的交接，即线程轮换在临界区执行。对于两个守护线程0和1，该方法伪代码如下：

对于线程0

```c
WHILE(*true*)｛

    //执行非临界区代码

    ……

    //准备进入临界区

    WHILE(*turn* != 0);

//进入临界区

    ……

    *turn* = 1; //将临界区执行权限转移给线程1

    //执行非临界区代码

    ……

}
```

对于线程1

```c
WHILE(*true*){

    //执行非临界区代码

    ......

    //准备进入临界区

    WHILE(*turn* !=1 );

    //进入临界区

    ......

    *turn* = 0; //将临界区执行权限转移给线程0

    //非临界区代码

    ......

}
```

上述方法是第一个可行的解决方案。分析一下线程执行逻辑，如果当前线程0位于临界区，则turn取值等于0，因此其他的线程无法进入临界区。如果当前线程1位于临界区，则turn等于1，则线程0无法进入临界区。

上述算法尽管可行，但其无法满足前述提到良好解决方案的最后一个条件，即位于非临界区的线程不应当阻塞其他线程。考虑如下情形，假设线程0执行为临界区代码后，turn更新为1，此时线程0开始执行非临界区代码，线程1执行其临界区代码。假设线程1很快执行完了其非临界区代码和临界区代码，将临界区执行权限转移给线程0，turn设置为0。此时线程1准备执行新一轮的临界区代码，它正在等待turn变量被线程0修改为1。而此时若线程0的非临界区代码执行耗时较大，则线程0仍然位于非临界区代码，由于线程0尚未进入临界区，因此无法将临界区执行权限转移给线程1。

因此，我们发现，在严格轮换法中，如果两个线程执行时间差异较大，则可能造成位于非临界区的线程阻塞其他线程。造成较大的CPU资源浪费。

## **3.4** Peterson算法

Peterson算法简洁易懂，对于包含多个线程的互斥算法，有两种实现方式，其实现如下。

第一种实现方式：

```c
do{

    flag[i] = TRUE;

    turn = j;

    while(flag[j] && turn == j);

    //执行临界区代码

   ……

    flag[i] = FALSE;

    //执行非临界区代码

    ……

} while(TRUE);
```

不难理解这其实是一种“谦让”的算法。线程i在进入之前，先看看其他线程有无进入临界区的想法。如果有，则等待其他线程执行完临界区的代码后，自己再进入。

第二种实现方式主要包含两个方法，在线程准备进入临界区前，调用enter_region方法，则线程执行完临界区代码后，准备退出前，调用leave_region方法。

```c
int[] interested = new int[N]

int turn; //记录当前有临界区执行权限的线程编号

void enter_region(int process){

	int other = 1 - process;

    interested[process] = true;

    turn = process;

    while(turn == process && interested[other] == true);

//执行临界区代码

……

}

void leave_region(int process){

	interested[process] = false;

}
```

上述代码能否实现线程在临界区的互斥呢？

先假设在交替执行的过程中，某一时刻线程i正处于临界区，那么interested[i] = TRUE 且 turn = i，那么这时如果线程j也想进临界区，它会先把interested[j]改为TRUE，然后把turn改为j。但它会在while循环那里忙等待，直到线程i退出了临界区，把interested[i]改为FALSE。

下面证明：

考虑线程0何时能够进入临界区？如果turn == 1或者turn == 0 && interested[1] == false, 则线程0能够进入临界区。

分析第一种情形：如果此时turn==1，是否可能证明线程1不在临界区呢？

证明：如果turn == 1, 则表明在线程0设置完turn之后，发生了线程切换，线程1执行并将turn设置为了1。对于线程1，此时turn == 1 && interested[0] == true, 因此线程1无法进入临界区。因此我们可以证明，对于线程0，如果此时turn==1，则线程1不在临界区，因此线程0可以安全进入临界区。

分析第二种情形，如果turn == 0 && interested[1] == false, 能够证明线程1不在临界区呢？

证明:如果turn == 0, 则此时线程1可能尚未进入临界区，此时线程0可以安全进入临界区。如果线程1当前进入了临界区，则interested[1]等于true, 因此与当前条件interested[1] == false相矛盾，因此在turn == 0 && interested[1] == false时，线程1不在临界区内，因此线程0可以安全进入临界区。

考虑线程1何时能够进入临界区时，证明是类似的。

## **3.5** TSL（Test and Set Lock）指令

现在来看需要硬件支持的一种方案。某些计算机中，特别是那些设计为多处理器的计算机，都有下面一条指令

```assembly
TSL RX,LOCK
```

称为测试并加锁（Test and Set Lock），它将一个内存字lock读到寄存器RX中，然后在该内存地址上存一个非零值。读字和写字操作保证是不可分割的，即该指令结束之前其他处理器均不允许访问该内存字。执行TSL指令的CPU将锁住内存总线，以禁止其他CPU在本指令结束之前访问内存。

在3.3中我们提到，由于读取变量与设置变量并非原子操作，因此在读取变量与设置变量间可能因CPU时钟中断造成线程切换。而TSL指令实现了读取变量与设置变量的原子性。我们可以在3.3的基础上基于TSL指令实现线程在临界区的互斥访问。

着重说明一下，锁住存储总线不同于屏蔽中断。屏蔽中断，然后在读内存字之后跟着写操作并不能阻止总线上的第二个处理器在读操作和写操作之间访问该内存字。事实上，在处理器1上屏蔽中断对处理器2根本没有任何影响。让处理器2远离内存直到处理器1完成的惟一方法就是锁住总线，这需要一个特殊的硬件设施（基本上，一根总线就可以确保总线由锁住它的处理器使用，而其他的处理器不能用）。

为了使用TSL指令，要使用一个共享变量lock来协调对共享内存的访问。当lock为0时，任何线程都可以使用TSL指令将其设置为1，并读写共享内存。当操作结束时，线程用一条普通的move指令将lock的值重新设置为0。

这条指令如何防止两个线程同时进入临界区呢？解决方案如下图所示。假定（但很典型）存在如下共4条指令的汇编语言子程序。第一条指令将lock原来的值复制到寄存器中并将lock设置为1，随后这个原来的值与0相比较。如果它非零，则说明以前已被加锁，则程序将回到开始并再次测试。经过或长或短的一段时间后，该值将变为0（当前处于临界区中的线程退出临界区时），于是过程返回，此时已加锁。要清除这个锁非常简单，程序只需将0存入lock即可，不需要特殊的同步指令。

![img](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041802798.gif)

​																														        		图2

现在有一种很明确的解法了。线程在进入临界区之前先调用enter_region，这将导致忙等待，直到锁空闲为止，随后它获得该锁并返回。在线程从临界区返回时它调用leave_region，这将把lock设置为0。与基于临界区问题的所有解法一样，线程必须在正确的时间调用enter_region和leave_region，解法才能奏效。如果一个线程有欺诈行为，则互斥将会失败。

一个可替代TSL的指令是XCHG，它原子性地交换了两个位置的内容，例如，一个寄存器与一个存储器字。代码下图所示，而且就像可以看到的那样，它本质上与TSL的解决办法一样。所有的Intel x86 CPU在低层同步中使用XCHG指令。

![img](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041802749.gif)

​                                                                                                                                        图3

这种实现方式的优点是：可以避免多进程对共享资源的同时访问。缺点是：①可能会造成死锁。②会过多的占用CPU资源，与多线程设计的初衷相矛盾。

## **3.6** 调整多线程程序的执行架构

在多线程运行过程中,如果存在多个线程竞争共享资源的情况,应尽量将使用共享资源的任务安排在一个线程中执行。而让使用资源不冲突的任务并行在多个线程执行。这样可以使程序结构变得简洁、层次性好，同时减少线程死锁的概率。

例如，对于一个绘图软件，并发启动了三条线程分别从键盘、终端和鼠标获得信号和输入，并将结果输出到屏幕上，其原本的多线程工作模式如图4，多个线程同时接收输入信号，进行相应检测，并向输出设备并发写数据。这使多个线程竞争显示设备。

![img](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041802328.gif)

​																										图4 多线程在绘图软件中的应用实例

对于利用上述方法进行修改，将要访问共享资源的部分分配到单独的线程中，三个线程利用管道将数据发送到单独的线程，三个线程访问管道时使用同步机制以防止竞争。图5是改进后的流程图。

![img](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041802046.gif)

​																											图5 采用安全机制的多线程示例

# **4**   操作系统中函数的安全性改进

下面介绍操作系统中为了保证多线程安全所采取的措施。

在Solaris和Linux等现代操作系统设计过程中，为避免多线程安全性问题，从函数级进行了改进，增加其运行的可靠性。例如，在Solaris操作系统中函数被划分为：安全的、大致安全的、不安全的、多线程安全的。多线程安全的函数是指：函数同时被多个线程调用时，函数仍然能保持其在逻辑上的正确性。例如：下面的例 1是不安全的，例2是多线程安全的。

例1：

```c
fputs(const char* s, FILE* stream){

   char* p;

   for(p = s; *p; p++){

       putc((int)* p, stream);

   }

}
```

例2：

```c
mutex_tm[NFILE];

fputs(const char* s, FILE* stream){

   char* p;

   mutex_lock(&m[fileno(stream)]);

   for(p = s; *p; p++){

     putc((int)* p, stream));

   }

   mutex_unlock(&m[fileno(STREAM)]);

}
```

在这个函数里，对输出函数使用了互斥锁机制。即使在多线程中使用了本函数，也不会造成线程竞争状况。在现代操作系统中，有一部分函数已经被设计成多线程安全函数，它们通常和普通函数在标注上有微小的差别。

另外，在操作系统中的一些函数在多线程中使用存在一定隐患。例如：输入/输出接口函数read()和write()。它们使用函数Iseek()来设置文件偏移量来确定操作的起始位置。当多线程对同一文件执行Iseek()操作时，若函数设置的偏移量不同就会引起混乱。为防止这种混乱，使用pread()和pwrite()函数，这两个函数指定自己的文件偏移量。 这些函数可以安全地在多线程中使用。在上例中将不安全的函数可以用多线程安全的函数代替。例如 read()函数，在函数接口级实现多线程安全。

# **5**   结 语

多线程的竞争状态是关系到整个系统安全性的潜在问题。它是由于程序中事件发生的相对时间冲突或共享资源竞争而引发的。它通常与同步错误一起出现。 使用多线程编程具有并行性高、通信方便、线程间切换代价小等优势使其广泛应用，但线程间执行顺序难以严格控制，对共享资源的冲突使用又使使用者要小心谨慎。在现今的多线程编程技术中竞争状态普遍存在，采取有效的控制机制和方法避免竞争状态的出现，减少由它引发的安全问题具有十分重要的意义。
Hello, RISC-V!

# 寄存器与函数调用

![image-20220319173627320](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041734344.png)

![img](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041734805.png)

![../_images/StackFrame.png](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041734409.png)

## 特殊寄存器x0有什么用？

RISC-V精简的厉害，没有NOP/NEG/J/BEQZ指令，但是可以特殊实现他们。

RISC-V的X0寄存器就相当于是硬件版的/dev/zero和/dev/null的组合体，从X0读出来的总是0,往X0写进去的总是被丢弃.

实现NOP指令，RISC-V没有提供nop指令，RISC-V用操作X0代替NOP,比如addi x0, x0, 0，因为数据写进去什么用都没…不产生影响。

实现NEG取负数，RISC-V用sub rd, x0, rs来实现，因为X0是0，所以他减去一个正数，就是负数了。

实现J指令跳转，RISC-V没有单独的J跳转指令，只有jal跳转链接指令，跳转之前总是要把下一条指令的地址拷贝到寄存器，但是如果用x0作为JAL的操作寄存器，即把下一条指令的地址拷贝到X0,那么效果就等价于j跳转指令了，因为写入X0的任何值都是会被丢弃~

RISC-V很多指令要多操作数，这时候X0的作用就很好了~

# RISC-V特权级架构

RISC-V 架构中一共定义了 4 种特权级：

| 级别  | 编码  | 名称                            |
| --- | --- | ----------------------------- |
| 0   | 00  | 用户/应用模式 (U, User/Application) |
| 1   | 01  | 监督模式 (S, Supervisor)          |
| 2   | 10  | 虚拟监督模式 (H, Hypervisor)        |
| 3   | 11  | 机器模式 (M, Machine)             |

其中，级别的数值越大，特权级越高，掌控硬件的能力越强。从表中可以看出， M 模式处在最高的特权级，而 U 模式处于最低的特权级。在CPU硬件层面，除了M模式必须存在外，其它模式可以不存在。

![../_images/PrivilegeStack.png](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041734091.png)

白色块表示一层执行环境，黑色块表示相邻两层执行环境之间的接口。这张图片给出了能够支持运行 Unix 这类复杂系统的软件栈。其中操作系统内核代码运行在 S 模式上；应用程序运行在 U 模式上。运行在 M 模式上的软件被称为 **监督模式执行环境** (SEE, Supervisor Execution Environment)，如在操作系统运行前负责加载操作系统的 Bootloader – RustSBI。站在运行在 S 模式上的软件视角来看，它的下面也需要一层执行环境支撑，因此被命名为 SEE，它需要在相比 S 模式更高的特权级下运行，一般情况下 SEE 在 M 模式上运行。

用户态应用直接触发从用户态到内核态的异常的原因总体上可以分为两种：其一是用户态软件为获得内核态操作系统的服务功能而执行特殊指令；其二是在执行某条指令期间产生了错误（如执行了用户态不允许执行的指令或者其他错误）并被 CPU 检测到。下表中我们给出了 RISC-V 特权级规范定义的会可能导致从低特权级到高特权级的各种 **异常**：

| Interrupt | Exception Code | Description                    |
| --------- | -------------- | ------------------------------ |
| 0         | 0              | Instruction address misaligned |
| 0         | 1              | Instruction access fault       |
| 0         | 2              | Illegal instruction            |
| 0         | 3              | Breakpoint                     |
| 0         | 4              | Load address misaligned        |
| 0         | 5              | Load access fault              |
| 0         | 6              | Store/AMO address misaligned   |
| 0         | 7              | Store/AMO access fault         |
| 0         | 8              | Environment call from U-mode   |
| 0         | 9              | Environment call from S-mode   |
| 0         | 11             | Environment call from M-mode   |
| 0         | 12             | Instruction page fault         |
| 0         | 13             | Load page fault                |
| 0         | 15             | Store/AMO page fault           |

其中 **断点** (Breakpoint) 和 **执行环境调用** (Environment call) 两种异常（为了与其他非有意为之的异常区分，会把这种有意为之的指令称为 *陷入* 或 *trap* 类指令，此处的陷入为操作系统中传统概念）是通过在上层软件中执行一条特定的指令触发的：执行 `ebreak` 这条指令之后就会触发断点陷入异常；而执行 `ecall` 这条指令时候则会随着 CPU 当前所处特权级而触发不同的异常。从表中可以看出，**当 CPU 分别处于 M/S/U 三种特权级时执行 `ecall` 这条指令会触发三种异常（分别参考上表 Exception Code 为 11/9/8 对应的行）。**

![../_images/EnvironmentCallFlow.png](https://cdn.jsdelivr.net/gh/p0lar1star/blog-img/202204041735599.png)

在这里我们需要说明一下执行环境调用 `ecall` ，这是一种很特殊的 *陷入* 类的指令， 上图中相邻两特权级软件之间的接口正是基于这种陷入机制实现的。M 模式软件 SEE 和 S 模式的内核之间的接口被称为 **监督模式二进制接口** (Supervisor Binary Interface, SBI)，而内核和 U 模式的应用程序之间的接口被称为 **应用程序二进制接口** (Application Binary Interface, ABI)，当然它有一个更加通俗的名字—— **系统调用** (syscall, System Call) 。而之所以叫做二进制接口，是因为它与高级编程语言的内部调用接口不同，是机器/汇编指令级的一种接口。事实上 M/S/U 三个特权级的软件可分别由不同的编程语言实现，即使是用同一种编程语言实现的，其调用也并不是普通的函数调用控制流，而是 **陷入异常控制流** ，在该过程中会切换 CPU 特权级。因此只有将接口下降到机器/汇编指令级才能够满足其跨高级语言的通用性和灵活性。

其他的异常则一般是在执行某一条指令的时候发生了某种错误（如除零、无效地址访问、无效指令等），或处理器认为处于当前特权级下执行的当前指令是高特权级指令或会访问不应该访问的高特权级的资源（可能危害系统）。碰到这些情况，就需要将控制转交给高特权级的软件（如操作系统）来处理。当错误/异常恢复后，则可重新回到低优先级软件去执行；如果不能恢复错误/异常，那高特权级软件可以杀死和清除低特权级软件，避免破坏整个执行环境。

# RISC-V特权指令

与特权级无关的一般的指令和通用寄存器 `x0` ~ `x31` 在任何特权级都可以使用。而**每个特权级都对应一些特殊指令**和 **控制状态寄存器** (CSR, Control and Status Register) ，来控制该特权级的某些行为并描述其状态。当然特权指令不仅具有读写 CSR 的指令，还有其他功能的特权指令。

如果处于低特权级状态的处理器执行了高特权级的指令，会产生非法指令错误的异常。这样，位于高特权级的执行环境能够得知低特权级的软件出现了错误，这个错误一般是不可恢复的，此时执行环境会将低特权级的软件终止。这在某种程度上体现了特权级保护机制的作用。

在 RISC-V 中，会有两类属于高特权级 S 模式的特权指令：

- 指令**本身属于高特权级的指令**，如 `sret` 指令（表示从 S 模式返回到 U 模式）。
- 指令访问了 [S模式特权级下才能访问的寄存器](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr) 或内存，如表示S模式系统状态的 **控制状态寄存器** `sstatus` 等。

RISC-V S模式部分特权指令如下：

| 指令              | 含义                                                                                                                                                                                 |
| --------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| sret            | 从 S 模式返回 U 模式：在 U 模式下执行会产生非法指令异常                                                                                                                                                   |
| wfi             | 处理器在空闲时进入低功耗状态等待中断：在 U 模式下执行会产生非法指令异常                                                                                                                                              |
| sfence.vma      | 刷新 TLB 缓存：在 U 模式下执行会产生非法指令异常                                                                                                                                                       |
| 访问 S 模式 CSR 的指令 | 通过访问 [sepc/stvec/scause/sscartch/stval/sstatus/satp等CSR](https://rcore-os.github.io/rCore-Tutorial-Book-v3/chapter2/4trap-handling.html#term-s-mod-csr) 来改变系统状态：在 U 模式下执行会产生非法指令异常 |

# RISC-V基本汇编指令

待更

# RISC-V中断

时间片轮转调度的核心机制就在于计时。操作系统的计时功能是依靠硬件提供的时钟中断来实现的。在介绍时钟中断之前，我们先简单介绍一下中断。

在 RISC-V 架构语境下， **中断** (Interrupt) 和我们第二章中介绍的异常（包括程序错误导致或执行 Trap 类指令如用于系统调用的 `ecall` ）一样都是一种 Trap ，但是它们被触发的原因却是不同的。对于某个处理器核而言， 异常与当前 CPU 的指令执行是 **同步** (Synchronous) 的，异常被触发的原因一定能够追溯到某条指令的执行；而中断则 **异步** (Asynchronous) 于当前正在进行的指令，也就是说中断来自于哪个外设以及中断如何触发完全与处理器正在执行的当前指令无关。

## 从底层硬件的角度区分同步和异步

从底层硬件的角度可能更容易理解这里所提到的同步和异步。以一个处理器的五级流水线设计而言，里面含有取指、译码、算术、访存、寄存器等单元，都属于执行指令所需的硬件资源。那么假如某条指令的执行出现了问题，一定能被其中某个单元看到并反馈给流水线控制单元，从而它会在执行预定的下一条指令之前先进入异常处理流程。也就是说，异常在这些单元内部即可被发现并解决。

而对于中断，可以理解为发起中断的是一套与处理器执行指令无关的电路（从时钟中断来看就是简单的计数和比较器），这套电路仅通过一根导线接入处理器。当外设想要触发中断的时候则输入一个高电平或正边沿，处理器会在每执行完一条指令之后检查一下这根线，看情况决定是继续执行接下来的指令还是进入中断处理流程。也就是说，大多数情况下，指令执行的相关硬件单元和可能发起中断的电路是完全独立 **并行** (Parallel) 运行的，它们中间只有一根导线相连。

RISC-V 的中断可以分成三类：

-   **软件中断** (Software Interrupt)：由**软件控制**发出的中断
-   **时钟中断** (Timer Interrupt)：由**时钟电路**发出的中断
-   **外部中断** (External Interrupt)：由**外设**发出的中断

与异常相比，中断和特权级之间的联系更紧密，可以看到这三种中断每一个都有 M/S 特权级两个版本。**中断的特权级可以决定该中断是否会被屏蔽**，以及需要 Trap 到 CPU 的哪个特权级进行处理。

在判断中断是否会被屏蔽的时候，有以下规则：

-   如果中断的特权级**低于** CPU 当前的特权级，则该中断会被屏蔽，不会被处理；
-   如果中断的特权级**高于** CPU 当前的特权级或相同，则需要通过相应的 CSR 判断该中断是否会被屏蔽。

以内核所在的 S 特权级为例，中断屏蔽相应的 CSR 有 `sstatus` 和 `sie` 。`sstatus` 的 `sie` 为 S 特权级的中断使能，能够同时控制三种中断，如果将其清零则会将它们全部屏蔽。即使 `sstatus.sie` 置 1 ，还要看 `sie` 这个 CSR，它的三个字段 `ssie/stie/seie` 分别控制 S 特权级的软件中断、时钟中断和外部中断的中断使能。比如对于 S 态时钟中断来说，如果 CPU 不高于 S 特权级，需要 `sstatus.sie` 和 `sie.stie` 均为 1 该中断才不会被屏蔽；如果 CPU 当前特权级高于 S 特权级，则该中断一定会被屏蔽。

如果中断没有被屏蔽，那么接下来就需要软件进行处理，而具体到哪个特权级进行处理与一些中断代理 CSR 的设置有关。默认情况下，所有的中断都需要到 M 特权级处理。而通过软件设置这些中断代理 CSR 之后，就可以到低特权级处理，但是 Trap 到的特权级不能低于中断的特权级。事实上所有的中断/异常默认也都是到 M 特权级处理的。

-   U 特权级的应用程序发出系统调用或产生错误异常都会跳转到 S 特权级的操作系统内核来处理；
-   S 特权级的时钟/软件/外部中断产生后，都会跳转到 S 特权级的操作系统内核来处理。

默认情况下，当中断产生并进入某个特权级之后，在中断处理的过程中同特权级的中断都会被屏蔽。中断产生后，硬件会完成如下事务：

-   当中断发生时，`sstatus.sie` 字段会被保存在 `sstatus.spie` 字段中，同时把 `sstatus.sie` 字段置零，这样软件在进行后续的中断处理过程中，所有 S 特权级的中断都会被屏蔽；
-   当软件执行中断处理完毕后，会执行 `sret` 指令返回到被中断打断的地方继续执行，硬件会把 `sstatus.sie` 字段恢复为 `sstatus.spie` 字段内的值。

也就是说，如果不去手动设置 `sstatus` CSR ，在只考虑 S 特权级中断的情况下，是不会出现 **嵌套中断** (Nested Interrupt) 的。嵌套中断是指在处理一个中断的过程中再一次触发了中断。由于默认情况下，在软件开始响应中断前， 硬件会自动禁用所有同特权级中断，自然也就不会再次触发中断导致嵌套中断了。
